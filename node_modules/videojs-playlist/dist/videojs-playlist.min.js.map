{"version":3,"sources":["node_modules/videojs-spellbook/node_modules/browserify/node_modules/browser-pack/_prelude.js","node_modules/global/window.js","src/js/index.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","videojsPlaylist","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","win","_interopDefault","ex","_typeof","videojs","validSeconds","isNaN","Infinity","reset","player","playlist","autoadvance_","timeout","clearTimeout","trigger","off","setup","delay","setTimeout","next","one","clearTracks","tracks","remoteTextTracks","removeRemoteTextTrack","playItem","item","replay","paused","ended","poster","src","sources","textTracks","forEach","addRemoteTextTrack","bind","play","assign","target","source","key","hasOwnProperty","sourceEquals","source1","source2","src1","src2","test","slice","indexOf","indexInSources","arr","Array","isArray","j","factory","initialList","initialIndex","arguments","undefined","list","newList","newIndex","currentItem","changeTimeout_","on","currentIndex_","player_","repeat_","index","currentSrc","contains","value","first","last","nextIndex","Math","min","previous","max","autoadvance","repeat","val","log","error","registerPlugin","plugin"],"mappings":"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","file":"/Users/poneill/dev/videojs-playlist/dist/videojs-playlist.min.js","sourceRoot":"","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar videojs = _interopDefault(require('video.js'));\nvar window = _interopDefault(require('global/window'));\n\n/**\n * Validates a number of seconds to use as the auto-advance delay.\n *\n * @private\n * @param   {number} s\n *          The number to check\n *\n * @return  {boolean}\n *          Whether this is a valid second or not\n */\nconst validSeconds = s =>\n  typeof s === 'number' && !isNaN(s) && s >= 0 && s < Infinity;\n\n/**\n * Resets the auto-advance behavior of a player.\n *\n * @param {Player} player\n *        The player to reset the behavior on\n */\nlet reset = (player) => {\n  if (player.playlist.autoadvance_.timeout) {\n    window.clearTimeout(player.playlist.autoadvance_.timeout);\n  }\n\n  if (player.playlist.autoadvance_.trigger) {\n    player.off('ended', player.playlist.autoadvance_.trigger);\n  }\n\n  player.playlist.autoadvance_.timeout = null;\n  player.playlist.autoadvance_.trigger = null;\n};\n\n/**\n * Sets up auto-advance behavior on a player.\n *\n * @param  {Player} player\n *         the current player\n *\n * @param  {number} delay\n *         The number of seconds to wait before each auto-advance.\n *\n * @return {undefined}\n *         Used to short circuit function logic\n */\nconst setup = (player, delay) => {\n  reset(player);\n\n  // Before queuing up new auto-advance behavior, check if `seconds` was\n  // called with a valid value.\n  if (!validSeconds(delay)) {\n    return;\n  }\n\n  player.playlist.autoadvance_.trigger = function() {\n    player.playlist.autoadvance_.timeout = window.setTimeout(() => {\n      reset(player);\n      player.playlist.next();\n    }, delay * 1000);\n  };\n\n  player.one('ended', player.playlist.autoadvance_.trigger);\n};\n\n/**\n * Removes all remote text tracks from a player.\n *\n * @param  {Player} player\n *         The player to clear tracks on\n */\nconst clearTracks = (player) => {\n  const tracks = player.remoteTextTracks();\n  let i = tracks && tracks.length || 0;\n\n  // This uses a `while` loop rather than `forEach` because the\n  // `TextTrackList` object is a live DOM list (not an array).\n  while (i--) {\n    player.removeRemoteTextTrack(tracks[i]);\n  }\n};\n\n/**\n * Plays an item on a player's playlist.\n *\n * @param  {Player} player\n *         The player to play the item on\n *\n * @param  {number} delay\n *         The number of seconds to wait before each auto-advance.\n *\n * @param  {Object} item\n *         A source from the playlist.\n *\n * @return {Player}\n *         The player that is now playing the item\n */\nconst playItem = (player, delay, item) => {\n  const replay = !player.paused() || player.ended();\n\n  player.trigger('beforeplaylistitem', item);\n  player.poster(item.poster || '');\n  player.src(item.sources);\n  clearTracks(player);\n  (item.textTracks || []).forEach(player.addRemoteTextTrack.bind(player));\n  player.trigger('playlistitem', item);\n\n  if (replay) {\n    player.play();\n  }\n\n  setup(player, delay);\n\n  return player;\n};\n\n// Lightweight Object.assign alternative.\nconst assign = (target, source) => {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n};\n\n/**\n * Given two sources, check to see whether the two sources are equal.\n * If both source urls have a protocol, the protocols must match, otherwise, protocols\n * are ignored.\n *\n * @private\n * @param {string|Object} source1\n *        The first source\n *\n * @param {string|Object} source2\n *        The second source\n *\n * @return {boolean}\n *         The result\n */\nconst sourceEquals = (source1, source2) => {\n  let src1 = source1;\n  let src2 = source2;\n\n  if (typeof source1 === 'object') {\n    src1 = source1.src;\n  }\n  if (typeof source2 === 'object') {\n    src2 = source2.src;\n  }\n\n  if (/^\\/\\//.test(src1)) {\n    src2 = src2.slice(src2.indexOf('//'));\n  }\n  if (/^\\/\\//.test(src2)) {\n    src1 = src1.slice(src1.indexOf('//'));\n  }\n\n  return src1 === src2;\n};\n\n/**\n * Look through an array of playlist items for a specific `source`;\n * checking both the value of elements and the value of their `src`\n * property.\n *\n * @private\n * @param   {Array} arr\n *          An array of playlist items to look through\n *\n * @param   {string} src\n *          The source to look for\n *\n * @return  {number}\n *          The index of that source or -1\n */\nconst indexInSources = (arr, src) => {\n  for (let i = 0; i < arr.length; i++) {\n    const sources = arr[i].sources;\n\n    if (Array.isArray(sources)) {\n      for (let j = 0; j < sources.length; j++) {\n        const source = sources[j];\n\n        if (source && sourceEquals(source, src)) {\n          return i;\n        }\n      }\n    }\n  }\n\n  return -1;\n};\n\n/**\n * Factory function for creating new playlist implementation on the given player.\n *\n * API summary:\n *\n * playlist(['a', 'b', 'c']) // setter\n * playlist() // getter\n * playlist.currentItem() // getter, 0\n * playlist.currentItem(1) // setter, 1\n * playlist.next() // 'c'\n * playlist.previous() // 'b'\n * playlist.first() // 'a'\n * playlist.last() // 'c'\n * playlist.autoadvance(5) // 5 second delay\n * playlist.autoadvance() // cancel autoadvance\n *\n * @param  {Player} player\n *         The current player\n *\n * @param  {Array=} initialList\n *         If given, an initial list of sources with which to populate\n *         the playlist.\n *\n * @param  {number=}  initialIndex\n *         If given, the index of the item in the list that should\n *         be loaded first. If -1, no video is loaded. If omitted, The\n *         the first video is loaded.\n *\n * @return {Function}\n *         Returns the playlist function specific to the given player.\n */\nconst factory = (player, initialList, initialIndex = 0) => {\n  let list = Array.isArray(initialList) ? initialList.slice() : [];\n\n  /**\n   * Get/set the playlist for a player.\n   *\n   * This function is added as an own property of the player and has its\n   * own methods which can be called to manipulate the internal state.\n   *\n   * @param  {Array} [newList]\n   *         If given, a new list of sources with which to populate the\n   *         playlist. Without this, the function acts as a getter.\n   *\n   * @param  {number}  [newIndex]\n   *         If given, the index of the item in the list that should\n   *         be loaded first. If -1, no video is loaded. If omitted, The\n   *         the first video is loaded.\n   *\n   * @return {Array}\n   *         The playlist\n   */\n  const playlist = player.playlist = function(newList, newIndex = 0) {\n    if (Array.isArray(newList)) {\n      list = newList.slice();\n      if (newIndex !== -1) {\n        playlist.currentItem(newIndex);\n      }\n      playlist.changeTimeout_ = window.setTimeout(() => {\n        player.trigger('playlistchange');\n      }, 0);\n    }\n\n    // Always return a shallow clone of the playlist list.\n    return list.slice();\n  };\n\n  player.on('loadstart', () => {\n    if (playlist.currentItem() === -1) {\n      reset(player);\n    }\n  });\n\n  player.on('dispose', () => {\n    window.clearTimeout(playlist.changeTimeout_);\n  });\n\n  assign(playlist, {\n    currentIndex_: -1,\n    player_: player,\n    autoadvance_: {},\n    repeat_: false,\n\n    /**\n     * Get or set the current item in the playlist.\n     *\n     * @param  {number} [index]\n     *         If given as a valid value, plays the playlist item at that index.\n     *\n     * @return {number}\n     *         The current item index.\n     */\n    currentItem(index) {\n      if (\n        typeof index === 'number' &&\n        playlist.currentIndex_ !== index &&\n        index >= 0 &&\n        index < list.length\n      ) {\n        playlist.currentIndex_ = index;\n        playItem(\n          playlist.player_,\n          playlist.autoadvance_.delay,\n          list[playlist.currentIndex_]\n        );\n      } else {\n        playlist.currentIndex_ = playlist.indexOf(playlist.player_.currentSrc() || '');\n      }\n\n      return playlist.currentIndex_;\n    },\n\n    /**\n     * Checks if the playlist contains a value.\n     *\n     * @param  {string|Object|Array} value\n     *         The value to check\n     *\n     * @return {boolean}\n     *         The result\n     */\n    contains(value) {\n      return playlist.indexOf(value) !== -1;\n    },\n\n    /**\n     * Gets the index of a value in the playlist or -1 if not found.\n     *\n     * @param  {string|Object|Array} value\n     *         The value to find the index of\n     *\n     * @return {number}\n     *         The index or -1\n     */\n    indexOf(value) {\n      if (typeof value === 'string') {\n        return indexInSources(list, value);\n      }\n\n      const sources = Array.isArray(value) ? value : value.sources;\n\n      for (let i = 0; i < sources.length; i++) {\n        const source = sources[i];\n\n        if (typeof source === 'string') {\n          return indexInSources(list, source);\n        } else if (source.src) {\n          return indexInSources(list, source.src);\n        }\n      }\n\n      return -1;\n    },\n\n    /**\n     * Plays the first item in the playlist.\n     *\n     * @return {Object|undefined}\n     *         Returns undefined and has no side effects if the list is empty.\n     */\n    first() {\n      if (list.length) {\n        return list[playlist.currentItem(0)];\n      }\n\n      playlist.currentIndex_ = -1;\n    },\n\n    /**\n     * Plays the last item in the playlist.\n     *\n     * @return {Object|undefined}\n     *         Returns undefined and has no side effects if the list is empty.\n     */\n    last() {\n      if (list.length) {\n        return list[playlist.currentItem(list.length - 1)];\n      }\n\n      playlist.currentIndex_ = -1;\n    },\n\n    /**\n     * Plays the next item in the playlist.\n     *\n     * @return {Object|undefined}\n     *         Returns undefined and has no side effects if on last item.\n     */\n    next() {\n\n      let nextIndex;\n\n      // Repeat\n      if (playlist.repeat_) {\n        nextIndex = playlist.currentIndex_ + 1;\n        if (nextIndex > list.length - 1) {\n          nextIndex = 0;\n        }\n\n      // Don't go past the end of the playlist.\n      } else {\n        nextIndex = Math.min(playlist.currentIndex_ + 1, list.length - 1);\n      }\n\n      // Make the change\n      if (nextIndex !== playlist.currentIndex_) {\n        return list[playlist.currentItem(nextIndex)];\n      }\n    },\n\n    /**\n     * Plays the previous item in the playlist.\n     *\n     * @return {Object|undefined}\n     *         Returns undefined and has no side effects if on first item.\n     */\n    previous() {\n\n      // Make sure we don't go past the start of the playlist.\n      const index = Math.max(playlist.currentIndex_ - 1, 0);\n\n      if (index !== playlist.currentIndex_) {\n        return list[playlist.currentItem(index)];\n      }\n    },\n\n    /**\n     * Sets up auto-advance on the playlist.\n     *\n     * @param {number} delay\n     *        The number of seconds to wait before each auto-advance.\n     */\n    autoadvance(delay) {\n      playlist.autoadvance_.delay = delay;\n      setup(playlist.player_, delay);\n    },\n\n    /**\n     * Sets `repeat` option, which makes the \"next\" video of the last video in the\n     * playlist be the first video in the playlist.\n     *\n     * @param {boolean=} val\n     *        The value to set repeat to\n     *\n     * @return {boolean}\n     *         The current value of repeat\n     */\n    repeat(val) {\n      if (val !== undefined) {\n        if (typeof val !== 'boolean') {\n          videojs.log.error('Invalid value for repeat', val);\n        } else {\n          playlist.repeat_ = val;\n        }\n      }\n      return playlist.repeat_;\n    }\n\n  });\n\n  playlist.currentItem(initialIndex);\n\n  return playlist;\n};\n\n// Video.js 5/6 cross-compatible.\nconst registerPlugin = videojs.registerPlugin || videojs.plugin;\n\n/**\n * The video.js playlist plugin. Invokes the playlist-maker to create a\n * playlist function on the specific player.\n *\n * @param {Array} list\n *        a list of sources\n *\n * @param {number} item\n *        The index to start at\n */\nconst plugin = function(list, item) {\n  factory(this, list, item);\n};\n\nregisterPlugin('playlist', plugin);\n\nmodule.exports = plugin;\n"]}